<!DOCTYPE html>
<html lang="en-us">

  <head>
    <meta charset="UTF-8">

    <title>CS Course Structure</title>
  </head>
  


  <body>

    <section class="page-header">
      <h1 class="project-name">Operating System</h1>
    </section>



<h3>Chap 8. Main Memory</h3>

<h4>
 The difference between the compile time address binding and execution time (run time) address binding. 
</h4>

<p>
The difference between load-time and run-time binding is that in run-time every time there is a memory lookup it goes through a "relocation register" which is like the base register and then you add an offset.

In load-time binding it does the same thing but subsequent lookups don't require evaluation of this register. The addresses are set when it is first pulled into memory. Hence if the base address changes you need to re-load the whole process to fix up all the relocatable addresses.

In the case of run-time, you can move the process around in physical memory and not need to worry about re-loading it to fix the mapping up because every time there is an access to memory it maps it then.

Load-time binding results in matching logical/physical addresses but run-time results in differing logical/physical addresses.

</p>

<h4>Does the swapped out process need to swap back in to same physical addresses?
</h4>

<p>
  compile-time or load-time address binding, swapped back into the same memory location.
execution time binding, swapped back into any available location.
</p>



<h3>8.3 Contiguous Memory Allocation</h3>
<ul>
  <li>Memory Protection</li>
  <p> protection against user programs accessing areas that they should not</p>
  <li>Memory Allocation</li>
  <p>strategies for finding the "best" allocation of memory to processes, First fit, Best fit, Worst fit</p>
  <li>Fragmentation</li>
  <p>external fragmentation & Internal fragmentation</p>
  To deal with fragmentation:
<ul>
  <li>compaction</li>
  <p>If the programs in memory are relocatable, ( using execution-time address binding ), then the external fragmentation problem can be reduced via compaction, i.e. moving all processes down to one end of physical memory. This only involves updating the relocation register for each process, as all internal work is done using logical addresses.</p>
  <li>Segmentation</li>
  <p>Another solution is allow processes to use non-contiguous blocks of physical memory, with a separate relocation register for each block.</p>
</ul>
</ul>




<h3>8.4 Memory Segmentation</h3>
<ul>
  <li>Basic Method (Programmer's view of a program.)</li>
  We think of memory in multiple segments, each dedicated to a particular use, such as code, data, the stack, the heap, etc. Memory segmentation supports this view by providing 
  <center>(segment number ( mapped to a segment base address ) ,  offset from the beginning of that segment.)</center>
  <img src="images/segmentation.jpg"/>

</ul>

Segmentation permits the physical address space of a process to be non-contiguous. Paging is another memory-management scheme that offer these advantage. And more, avoid external fragmentation. Now, the logical address space is totally separated from the physical space. So, a process can have a address space even larger than the physical memory.

<h3>8.5 Paging</h3>

Paging: eliminates most of the problems of the other methods discussed previously, and is the predominant memory management technique used today. Paging is a memory management scheme that allows processes physical memory to be discontinuous, and which eliminates problems with fragmentation by allocating memory in equal sized blocks known as pages.
<ul>
  <li>Basic Method (pages --- frames)</li>
  divide physical memory into a number of equal sized blocks called frames,  divide a programs logical memory space into blocks of the same size called pages.
    
    <img src="images/paging.jpg"/>

</ul>

  
  </body>
</html>
