<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>mucha.GitHub.io by QQshigesha</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  


  <body>

    <section class="page-header">
      <h1 class="project-name">Operating System</h1>
    </section>



<h3>Chap 8. Main Memory</h3>

<h4>
 The difference between the compile time address binding and execution time (run time) address binding. 
</h4>

<p>
The difference between load-time and run-time binding is that in run-time every time there is a memory lookup it goes through a "relocation register" which is like the base register and then you add an offset.

In load-time binding it does the same thing but subsequent lookups don't require evaluation of this register. The addresses are set when it is first pulled into memory. Hence if the base address changes you need to re-load the whole process to fix up all the relocatable addresses.

In the case of run-time, you can move the process around in physical memory and not need to worry about re-loading it to fix the mapping up because every time there is an access to memory it maps it then.

Load-time binding results in matching logical/physical addresses but run-time results in differing logical/physical addresses.

</p>

<h4>Does the swapped out process need to swap back in to same physical addresses?
</h4>

<p>
  compile-time or load-time address binding, swapped back into the same memory location.
execution time binding, swapped back into any available location.
</p>



<h3>8.3 Contiguous Memory Allocation</h3>
<ul>
  <li>Memory Protection</li>
  <p> protection against user programs accessing areas that they should not</p>
  <li>Memory Allocation</li>
  <p>strategies for finding the "best" allocation of memory to processes, First fit, Best fit, Worst fit</p>
  <li>Fragmentation</li>
  <p>external fragmentation & Internal fragmentation</p>
  To deal with fragmentation:
<ul>
  <li>compaction</li>
  <p>If the programs in memory are relocatable, ( using execution-time address binding ), then the external fragmentation problem can be reduced via compaction, i.e. moving all processes down to one end of physical memory. This only involves updating the relocation register for each process, as all internal work is done using logical addresses.</p>
  <li>Segmentation</li>
  <p>Another solution is allow processes to use non-contiguous blocks of physical memory, with a separate relocation register for each block.</p>
</ul>
</ul>




<h3>8.4 Segmentation</h3>
now, let's start!

  
  </body>
</html>
